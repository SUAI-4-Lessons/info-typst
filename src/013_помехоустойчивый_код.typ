#import "@preview/gentle-clues:1.1.0": *

= Помехоустойчивый код

#figure(image("images/13_модель_канала_передачи.png", width: 70%))

При передачи сообщения от источника к получателю в канале связи могут возникнуть
ошибки.

И что тогда сделать чтобы их избежать?

Варианты решения:

1. #strike[Плакать]
2. Отправлять дополнительную информацию в сообщении для проверки на стороне
  получателя

== Помехоустойчивость код с проверкой на чётность <24>

Это одна из самых простых проверок, основной смысл которой рассчитать чётное ли
количество единиц в сообщении или нет.

Для этого использовали $xor$ на каждый бит сообщения $D_i$:

$
  P = D_1 xor D_2 xor D_3 ... xor D_n
$

В итоге добавляем этот бит к исходному сообщению и на стороне клиента проверяем
сохранила ли чётность наше сообщение.

#example[
  Исходное сообщение: 101011

  Рассчитаем бит чётности: $ P = 1 xor 0 xor 1 xor 0 xor 1 xor 1 = 0 $

  Закодированное сообщение: 101011 0

  Полученное сообщение: 101001 0

  Рассчитаем бит чётности: $ P = 1 xor 0 xor 1 xor 0 xor 0 xor 1 = 1 $

  Значит в ходе передачи сообщения была помеха, но где ошибка и как её исправить
  не понятно.
]

#table(
  columns: 2,
  table.header([➕ Плюсы], [➖ Минусы]),
  [Простота реализации],
  [Невозможность понять положение ошибки $=>$ невозможно исправить],
  [Минимальная избыточность (к сообщению добавляем всего 1 бит)],
  [При изменении чётного количества байт невозможно найти ошибку],
)

== Код Хэмминга <22>

/ Систематический код: -- такой код, в котором можно явно выделить
информационные и проверочные разряды.

Алгоритм для кодирования сообщения в код Хэмминга:

1. В сообщении в позициях со степенью двойки ставим пропуски

  Например если сообщение 1101 $=>$ \_ \_ 1 \_ 1 0 1

2. Теперь для каждой позиции бита чётности рассчитаем их последующему алгоритму:

  + Определим $i$ как нумерацию бита чётности (1 2 \_ 3 \_ \_ \_)
  + Тогда все позиции чисел участвующих в расчёте для бита чётности будут
    следующими: переводи номер позиции в двоичный вид и берём все позиции у которых
    в двоичном виде на позиции $i$ стоит 1

При декодировании мы делаем тоже самое, только проверяем получившиеся биты
чётности. При этом при получении ошибки мы понимаем где она расположив все биты
чётности в обратном порядке

#table(
  columns: 2,
  table.header([➕ Плюсы], [➖ Минусы]),
  [Простота реализации],
  [Невозможность понять положение ошибки $=>$ невозможно исправить],
  [Минимальная избыточность (к сообщению добавляем всего 1 бит)],
  [При изменении чётного количества байт невозможно найти ошибку],
)

#example(
  )[
  *Кодирование*

  1. Исходное сообщение: $D_1 = 1, D_2 = 0, D_3 = 1, D_4 = 1$.
  2. Проверочные биты $P_1, P_2, P_4$ на позициях $1, 2, 4$.
  3. Структура сообщения: $P_1, P_2, D_1, P_4, D_2, D_3, D_4$.

  Заполняем:
  $
    \_ \_ 1 \_ 0 1 1
  $

  Вычисляем:
  - $P_1 = D_1 xor D_2 xor D_4 = 1 xor 0 xor 1 = 0$,
  - $P_2 = D_1 xor D_3 xor D_4 = 1 xor 1 xor 1 = 1$,
  - $P_4 = D_2 xor D_3 xor D_4 = 0 xor 1 xor 1 = 0$.

  Итоговое сообщение:
  $
    0 \, 1 \, 1 \, 0 \, 0 \, 1 \, 1
  $

  *Декодирование*

  Принятое сообщение: $0 \, 1 \, 1 \, 0 \, 0 \, 0 \, 1$ (ошибка в 6-й позиции).

  1. Проверяем $P_1, P_2, P_4$:
    - $P_1 = 1$, $P_2 = 1$, $P_4 = 0$.
  2. Синдром: $P_4P_2P_1 = 011 = 6$.

  Ошибка в позиции 6. Исправляем:
  $
    0 \, 1 \, 1 \, 0 \, 0 \, 1 \, 1
  $

  Расшифровка: $D_1 = 1, D_2 = 0, D_3 = 1, D_4 = 1$.
]

== Расстояние Хэмминга

/ Расстояние Хэмминга: --- число позиций, в которых соответствующие
символы двух слов одинаковой длины различны.

Два слова расстояние Хэмминга между которыми равно 1, называют соседними.

=== Кодовое расстояние

/ Минимальное расстояние помехоустойчивого кода $d_min$: --- это наименьшее расстояние Хэмминга для всех разрешённых кодовых комбинаций.


Можно найти если просто перечислить все возможные комбинации или графически:

Минимальное расстояние  кода  $d_min$  
равно числу ребер единичного куба, которое нужно пройти между двумя разрешенными кодовыми комбинациями по наименьшему пути.

#image("images/16_граф_код_раст.png")


=== Корректирующая способность <23>

/ Корректирующая способность: --- кратность ошибок, которые помехоустойчивый код может:
  1. Только обнаружить без возможности исправления - $r$, $d_min >= r + 1$

  2. Только исправить без возможности обнаружения ошибок большей кратности - $S$, $d_min >= 2S + 1$

  3. Исправить S ошибок и обнаружитть r ошибок, $r > s$; $d_min >= S + r + 1$

